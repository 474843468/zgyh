package com.boc.bocsoft.mobile.bocmobile.base.widget.dialogview.securityverify.eshield;import android.content.Context;import android.graphics.drawable.Drawable;import android.os.Handler;import android.text.Editable;import android.text.InputFilter;import android.text.InputType;import android.text.Selection;import android.text.Spannable;import android.text.TextUtils;import android.text.TextWatcher;import android.util.AttributeSet;import android.view.KeyEvent;import android.view.MotionEvent;import android.view.View;import android.view.View.OnFocusChangeListener;import android.view.View.OnTouchListener;import android.view.inputmethod.EditorInfo;import android.view.inputmethod.InputConnection;import android.view.inputmethod.InputMethodManager;import android.widget.EditText;import com.boc.bocsoft.mobile.bocmobile.R;import com.boc.bocsoft.mobile.bocmobile.base.widget.dialogview.securityverify.CFCAEditTextView;import com.boc.device.key.BOCMAKeyPinSecurity;import java.util.regex.Pattern;/** * 带全键盘的虚拟输入框 create by lxw 修改音频key密码时使用 */public class PESAPModifyPassEdittext extends EditText implements        OnTouchListener, OnFocusChangeListener, PassKeybroadPop.InputCompleteListener {    private Context mContext;    private Drawable mNormaldDrawable;    private Drawable mErrorDrawable;    private MEBEdittextDelegator mDelegator;    // 真实值    private String numText = "";    private boolean isPassword = true;    private boolean isKeyBroadShow;    // 弹出的键盘    private PassKeybroadPop keyPop;    public PESAPModifyPassEdittext(Context context, AttributeSet attrs, int defStyle) {        super(context, attrs, defStyle);        mContext = context;        init();    }    public PESAPModifyPassEdittext(Context context, AttributeSet attrs) {        super(context, attrs);        mContext = context;        init();    }    public PESAPModifyPassEdittext(Context context) {        super(context);        mContext = context;        init();    }    public void setSecurityKeyboardListener(CFCAEditTextView.SecurityKeyboardListener securityKeyboardListener) {        keyPop.setSecurityKeyboardListener(securityKeyboardListener);    }    /**     * @return 获取键盘输入的未加密数据     */    public String getInputText() {        return numText;    }    /**     * 获取加密后的值     *     * @param random     * @param sessionId     * @return 真实值加密后的值     */    public String getEncryptText(String random, String sessionId) {        if (isRegex(numText)) {            return new String(BOCMAKeyPinSecurity.encryptWithKeyPin(numText,                    random, sessionId));        } else {            return "";        }    }    public InputConnection onCreateInputConnection(EditorInfo outAttrs) {        InputConnection ic = super.onCreateInputConnection(outAttrs);        if (getContext() != null) {            InputMethodManager localInputMethodManager;            if ((localInputMethodManager = (InputMethodManager) getContext()                    .getSystemService(Context.INPUT_METHOD_SERVICE)) != null) {                localInputMethodManager.hideSoftInputFromWindow(                        getWindowToken(), 0);            }        }        return ic;    }    private void init() {        keyPop = new PassKeybroadPop(mContext);        keyPop.setInputCompleteListener(this);        setOnTouchListener(this);        setOnFocusChangeListener(this);        setLongClickable(false);        mErrorDrawable = getResources().getDrawable(R.drawable.pesap_input_selct_error);        mNormaldDrawable = getResources().getDrawable(R.drawable.pesap_input_normal);        //PublicUtils.setEditTextCourse(this);        //this.setCursorVisible(false);        setOnClickListener(new OnClickListener() {            @Override            public void onClick(View v) {                showKeyBroad();            }        });        addTextChangedListener(new TextWatcher() {            @Override            public void onTextChanged(CharSequence s, int start, int before,                                      int count) {                if (s instanceof Spannable) {                    Spannable spanText = (Spannable) s;                    Selection.setSelection(spanText, s.length());                }            }            @Override            public void beforeTextChanged(CharSequence s, int start, int count, int after) {            }            @Override            public void afterTextChanged(Editable s) {                if (keyPop != null) {                    numText = keyPop.getContentText();                    if (TextUtils.isEmpty(s.toString())) {                        numText = "";                    }                }                if (mDelegator != null) {                    mDelegator.onTextChange();                }            }        });    }    @Override    public boolean onKeyDown(int keyCode, KeyEvent event) {        if (keyCode == KeyEvent.KEYCODE_BACK && keyPop != null                && keyPop.isShowing()) {            hiddenKeyBroad();            return true;        }        return super.onKeyDown(keyCode, event);    }    @Override    public void onFocusChange(View v, boolean hasFocus) {        if (!hasFocus) {            hiddenKeyBroad();        }    }    /**     * 判断是否显示输入法     *     * @return     */    public boolean isKeyBroadShow() {        return isKeyBroadShow;    }    /**     * 设置输入法为password 格式     */    public void setInputTypePassword() {        isPassword = true;        setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);    }    /**     * 弹出数字键盘     */    public void showKeyBroad() {        if (keyPop != null && !keyPop.isShowing() && getVisibility() == View.VISIBLE) {            keyPop.showKeyBroad();            if (mDelegator != null) {                mDelegator.onKeyboardShow();            }        }    }    /**     * 隐藏数字键盘     */    public void hiddenKeyBroad() {        if (keyPop != null && keyPop.isShowing()) {            isKeyBroadShow = false;            keyPop.hiddenKeyBroad(numText);        }    }    public void setInputCompleteListener(PassKeybroadPop.InputCompleteListener inputCompleteListener) {        keyPop.setInputCompleteListener(inputCompleteListener);    }    /**     * 设置输入法可输入的最大长度     *     * @param max     */    public void setMaxLength(int max) {        if (max >= 0) {            setFilters(new InputFilter[]{new InputFilter.LengthFilter(max)});        }    }    protected String getRealValue() {        return numText;    }    @Override    protected void onDetachedFromWindow() {        hiddenKeyBroad();        super.onDetachedFromWindow();    }    private Handler mHandler = new Handler() {        public void handleMessage(android.os.Message msg) {            if (msg.what == 0) {                showKeyBroad();                setCursorVisible(true);            }        }        ;    };    @Override    public boolean onTouch(View v, MotionEvent event) {        requestFocus();        requestFocusFromTouch();        mHandler.sendEmptyMessage(0);        this.onTouchEvent(event);        if (isPassword) {            setInputType(InputType.TYPE_CLASS_TEXT                    | InputType.TYPE_TEXT_VARIATION_PASSWORD);        } else {            super.setInputType(InputType.TYPE_CLASS_TEXT);        }        super.setSelection(getText().length());        return true;    }    /**     * 设置监听 当文字发生改变时调用     */    public void setEdittextDelegator(MEBEdittextDelegator mDelegator) {        this.mDelegator = mDelegator;    }    public boolean isRegex(String text) {        if (text.length() != 8)            return false;        if (Pattern.matches("^[a-zA-Z]+$", text)) {            return false;        }        if (Pattern.matches("^[0-9]+$", text)) {            return false;        }        return true;    }    @Override    public void onInputComplete() {    }    @Override    public void textChanged(String value) {        numText = value;        setText(numText);    }    /**     * 自定义虚拟键盘弹出     */    public static interface MEBEdittextDelegator {        public abstract void onKeyboardShow();        /**         * 当内容改变时 回调         */        public abstract void onTextChange();    }    public void setError() {        this.setBackgroundDrawable(mErrorDrawable);    }    public void clearError() {        this.setBackgroundDrawable(mNormaldDrawable);    }    public void clear() {        keyPop.clear();    }}